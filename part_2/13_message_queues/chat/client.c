
#include <stdio.h> // Подключение стандартной библиотеки ввода-вывода
#include <stdlib.h> // Подключение стандартной библиотеки для работы с памятью и процессами
#include <string.h> // Подключение библиотеки для работы со строками
#include <sys/ipc.h> // Подключение библиотеки для работы с IPC (межпроцессное взаимодействие)
#include <sys/msg.h> // Подключение библиотеки для работы с очередями сообщений
#include <pthread.h> // Подключение библиотеки для работы с потоками
#include <ncurses.h> // Подключение библиотеки для работы с интерфейсом в терминале

#define MAX_TEXT 512 // Определение максимальной длины текста сообщения
#define MAX_USERS 10 // Определение максимального количества пользователей

// Структура для сообщения
struct message {
    long msg_type; // Тип сообщения
    char msg_text[MAX_TEXT]; // Текст сообщения
};

// Окна для интерфейса
WINDOW *messages_win, *users_win, *input_win; // Окна для сообщений, списка пользователей и ввода
int msgid; // Идентификатор очереди сообщений
char users[MAX_USERS][MAX_TEXT]; // Массив имен пользователей
int user_count = 0; // Количество пользователей
char username[MAX_TEXT]; // Имя текущего пользователя

// Прототипы функций
void *receive_messages(void *arg);
void init_windows();
void update_users();
void update_messages(const char *message);

// Функция для получения сообщений в отдельном потоке
void *receive_messages(void *arg) {
    struct message msg; // Переменная для хранения сообщения
    while (1) { // Бесконечный цикл для получения сообщений
        // Получение сообщения из очереди
        if (msgrcv(msgid, &msg, sizeof(msg.msg_text), 0, 0) == -1) { // Получение сообщения любого типа
            perror("msgrcv"); // Вывод ошибки
            exit(1); // Завершение программы с ошибкой
        }
        // Обработка сообщения
        if (msg.msg_type == 1) { // Если сообщение типа 1
            // Вывод сообщения в окно сообщений
            update_messages(msg.msg_text); // Обновление окна сообщений
        } else if (msg.msg_type == 2) { // Если сообщение типа 2
            // Обновление списка пользователей
            char *token = strtok(msg.msg_text, ","); // Разделение строки на имена пользователей
            user_count = 0; // Сброс счетчика пользователей
            while (token != NULL && user_count < MAX_USERS) { // Пока есть имена и не превышен максимум
                strcpy(users[user_count++], token); // Копирование имени пользователя в массив
                token = strtok(NULL, ","); // Получение следующего имени
            }
            update_users(); // Обновление окна списка пользователей

            // Формирование сообщения о подключении нового пользователя
            if (user_count > 0) {
                char join_msg[MAX_TEXT];
                snprintf(join_msg, MAX_TEXT, "**User %s has joined the chat**", users[user_count - 1]);
                update_messages(join_msg); // Обновление окна сообщений
            }
        }
    }
    return NULL; // Завершение потока
}

// Функция для инициализации окон интерфейса
void init_windows() {
    int height, width; // Переменные для хранения размеров терминала
    // Получение размеров терминала
    getmaxyx(stdscr, height, width); // Получение размеров стандартного окна

    // Создание окна для сообщений
    messages_win = newwin(height - 3, width - 20, 0, 0); // Создание окна для сообщений
    // Создание окна для списка пользователей
    users_win = newwin(height - 3, 20, 0, width - 20); // Создание окна для списка пользователей
    // Создание окна для ввода сообщений
    input_win = newwin(3, width, height - 3, 0); // Создание окна для ввода сообщений

    // Отрисовка рамок для окон
    box(messages_win, 0, 0); // Отрисовка рамки для окна сообщений
    box(users_win, 0, 0); // Отрисовка рамки для окна списка пользователей
    box(input_win, 0, 0); // Отрисовка рамки для окна ввода сообщений

    // Отображение заголовка для окна пользователей
    mvwprintw(users_win, 1, 1, "Users:"); // Вывод заголовка в окно списка пользователей
    wrefresh(messages_win); // Обновление окна сообщений
    wrefresh(users_win); // Обновление окна списка пользователей
    wrefresh(input_win); // Обновление окна ввода сообщений
}

// Функция для обновления списка пользователей
void update_users() {
    // Очистка окна пользователей
    werase(users_win); // Очистка окна списка пользователей
    box(users_win, 0, 0); // Отрисовка рамки для окна списка пользователей
    mvwprintw(users_win, 1, 1, "Users:"); // Вывод заголовка в окно списка пользователей
    // Вывод списка пользователей
    for (int i = 0; i < user_count; i++) { // Проход по всем пользователям
        mvwprintw(users_win, i + 2, 1, "%s", users[i]); // Вывод имени пользователя
    }
    wrefresh(users_win); // Обновление окна списка пользователей
}

void update_messages(const char *message) {
    int max_y, max_x;
    getmaxyx(messages_win, max_y, max_x); // Получение размеров окна
    int n = 2; // Количество строк, занимаемых рамкой

    // Проверка, нужно ли прокручивать окно
    if (getcury(messages_win) >= max_y - n - 1) {
        // Копирование всей области сообщений и перерисовка со смещением на одну строку вверх
        for (int i = 1; i < max_y - n - 1; i++) {
            char buffer[max_x];
            mvwinstr(messages_win, i + 1, 1, buffer); // Копирование строки
            mvwprintw(messages_win, i, 1, "%-*s", max_x - 2, buffer); // Перерисовка строки на одну строку вверх
        }
        // Очистка последней строки
        mvwprintw(messages_win, max_y - n - 1, 1, "%-*s", max_x - 2, " ");
    }

    // Перемещение курсора в конец окна
    wmove(messages_win, max_y - n - 1, 1);

    // Вывод нового сообщения в окно сообщений
    wprintw(messages_win, "%s", message); // Вывод сообщения в окно
    box(messages_win, 0, 0); // Отрисовка рамки для окна сообщений
    wrefresh(messages_win); // Обновление окна сообщений
}

int main() {
    key_t key; // Переменная для хранения ключа
    struct message msg; // Переменная для хранения сообщения
    pthread_t recv_thread; // Переменная для хранения идентификатора потока

    // Генерация уникального ключа
    key = ftok("server", 65); // Генерация ключа на основе файла и идентификатора

    // Подключение к очереди сообщений
    msgid = msgget(key, 0666 | IPC_CREAT); // Подключение к очереди сообщений с правами доступа 0666
    if (msgid == -1) { // Проверка на ошибку подключения к очереди
        perror("msgget"); // Вывод ошибки
        exit(1); // Завершение программы с ошибкой
    }

    // Инициализация ncurses
    initscr(); // Инициализация библиотеки ncurses
    cbreak(); // Отключение буферизации ввода
    echo(); // Включение отображения вводимых символов
    keypad(stdscr, TRUE); // Включение обработки функциональных клавиш

    // Инициализация окон интерфейса
    init_windows(); // Вызов функции инициализации окон

    // Запуск потока для получения сообщений
    pthread_create(&recv_thread, NULL, receive_messages, NULL); // Создание потока для получения сообщений

    // Ввод имени пользователя
    mvwprintw(input_win, 1, 1, "Enter your name: "); // Вывод приглашения для ввода имени
    wrefresh(input_win); // Обновление окна ввода сообщений
    wgetnstr(input_win, username, MAX_TEXT); // Получение строки ввода от пользователя

    // Отправка сообщения о новом пользователе серверу
    msg.msg_type = 2; // Установка типа сообщения для нового пользователя
    snprintf(msg.msg_text, MAX_TEXT, "%s", username); // Формирование сообщения о новом пользователе
    if (msgsnd(msgid, &msg, sizeof(msg.msg_text), 0) == -1) { // Отправка сообщения в очередь
        perror("msgsnd"); // Вывод ошибки
        exit(1); // Завершение программы с ошибкой
    }

    // Установка типа сообщения для обычных сообщений
    msg.msg_type = 1; // Установка типа сообщения

    while (1) { // Бесконечный цикл для ввода сообщений
        // Очистка окна ввода
        werase(input_win); // Очистка окна ввода сообщений
        box(input_win, 0, 0); // Отрисовка рамки для окна ввода сообщений
        mvwprintw(input_win, 1, 1, "Enter message: "); // Вывод приглашения для ввода сообщения
        wrefresh(input_win); // Обновление окна ввода сообщений

        // Получение строки ввода от пользователя
        wgetnstr(input_win, msg.msg_text, MAX_TEXT); // Получение строки ввода от пользователя

        // Добавление имени пользователя к сообщению
        char full_msg[MAX_TEXT];
        snprintf(full_msg, MAX_TEXT, "%s: %s", username, msg.msg_text);
        strncpy(msg.msg_text, full_msg, MAX_TEXT);

        // Отправка сообщения серверу
        if (msgsnd(msgid, &msg, sizeof(msg.msg_text), 0) == -1) { // Отправка сообщения в очередь
            perror("msgsnd"); // Вывод ошибки
            exit(1); // Завершение программы с ошибкой
        }
    }

    // Завершение работы ncurses
    endwin(); // Завершение работы с ncurses
    return 0; // Завершение программы
}
